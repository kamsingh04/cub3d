I COULD RENDER THE player

Clear the screen: Clear the screen by filling it with a background color or texture.
Set up the camera: Set up the camera's position, angle, and field of view (FOV)
 based on the player's position and angle.
Cast rays: Cast rays from the camera into the game world, one for each pixel
 on the screen.
Check for collisions: Check if each ray collides with a wall or other objects
 in the game world.
Calculate distances and angles: Calculate the distance and angle of each collision.
Determine the texture and color: Determine the texture and color of each wall or 
object based on the collision.
Render the walls and objects: Render the walls and objects on the screen using 
the calculated distances, angles, and textures.
Render the floor and ceiling: Render the floor and ceiling based on the player's
 position and angle.
Render the player: Render the player's character or avatar on the screen.
Render any additional effects: Render any additional effects such as lighting, 
shadows, or particles.

void render_scene(t_game *game) {
    // Clear the screen
    for (int y = 0; y < SCREEN_HEIGHT; y++) {
        for (int x = 0; x < SCREEN_WIDTH; x++) {
            plot_pixel(game, x, y, 0x000000); // clear with black color
        }
    }

    // Set up the camera
    double camera_x = game->player_x;
    double camera_y = game->player_y;
    double camera_angle = game->player_angle;

    // Cast rays
    for (int x = 0; x < SCREEN_WIDTH; x++) {
        double ray_angle = camera_angle + (x - SCREEN_WIDTH / 2) * game->player_fov_radian / SCREEN_WIDTH;
        double ray_dist = 0;
        int ray_wallflag = 0;

        // Check for collisions
        for (int i = 0; i < MAX_STEPS; i++) {
            double ray_x = camera_x + ray_dist * cos(ray_angle);
            double ray_y = camera_y + ray_dist * sin(ray_angle);

            // Check if the ray hits a wall
            if (check_collision(game, ray_x, ray_y)) {
                ray_wallflag = 1;
                break;
            }

            ray_dist += 0.1;
        }

        // Calculate distances and angles
        double wall_dist = ray_dist * cos(ray_angle - camera_angle);
        double wall_angle = atan2(ray_y - camera_y, ray_x - camera_x);

        // Determine the texture and color
        int texture_id = get_texture_id(game, wall_angle);
        int color = get_color(game, texture_id);

        // Render the wall
        for (int y = 0; y < SCREEN_HEIGHT; y++) {
            int wall_height = (int)(SCREEN_HEIGHT / wall_dist);
            int wall_top = (SCREEN_HEIGHT - wall_height) / 2;
            int wall_bottom = wall_top + wall_height;

            if (y >= wall_top && y < wall_bottom) {
                plot_pixel(game, x, y, color);
            }
        }
    }

    // Render the floor and ceiling
    render_floor_and_ceiling(game);

    // Render the player
    render_player(game);
}



RENDER FROM PLAYER'S FOV

#include <math.h>
#include <stdint.h>

#define SCREEN_WIDTH 320
#define SCREEN_HEIGHT 200
#define MAP_WIDTH 20
#define MAP_HEIGHT 20
#define FOV 60.0

typedef struct {
    double x, y;
} Vector2D;

typedef struct {
    int width, height;
    char data[MAP_WIDTH * MAP_HEIGHT];
} Map;

typedef struct {
    double x, y;
    double angle;
    double fov_radian;
} Player;

void render_wall(double distance, int x, int texture_id, uint16_t *screen) {
    int wall_height = (int)(SCREEN_HEIGHT / distance);
    int wall_top = (SCREEN_HEIGHT - wall_height) / 2;
    int wall_bottom = wall_top + wall_height;

    for (int y = wall_top; y < wall_bottom; y++) {
        uint16_t color = get_texture_color(texture_id, y, wall_height);
        screen[y * SCREEN_WIDTH + x] = color;
    }
}

void cast_ray(Map *map, Player *player, int x, double *distance, int *wallflag) {
    double ray_angle = player->angle + (x - SCREEN_WIDTH / 2) * player->fov_radian / SCREEN_WIDTH;
    double ray_x = player->x;
    double ray_y = player->y;
    double ray_dx = cos(ray_angle);
    double ray_dy = sin(ray_angle);

    *distance = 0;
    *wallflag = 0;

    while (*distance < 20) {
        ray_x += ray_dx;
        ray_y += ray_dy;
        *distance += 0.1;

        int map_x = (int)ray_x;
        int map_y = (int)ray_y;

        if (map_x >= 0 && map_x < MAP_WIDTH && map_y >= 0 && map_y < MAP_HEIGHT) {
            if (map->data[map_y * MAP_WIDTH + map_x] == 1) {
                *wallflag = 1;
                break;
            }
        }
    }
}

void render_scene(Map *map, Player *player, uint16_t *screen) {
    for (int x = 0; x < SCREEN_WIDTH; x++) {
        double distance;
        int wallflag;

        cast_ray(map, player, x, &distance, &wallflag);

        if (wallflag) {
            int texture_id = get_texture_id(map, player->angle + (x - SCREEN_WIDTH / 2) * player->fov_radian / SCREEN_WIDTH);
            render_wall(distance, x, texture_id, screen);
        } else {
            // render background
            for (int y = 0; y < SCREEN_HEIGHT; y++) {
                screen[y * SCREEN_WIDTH + x] = 0x0000; // clear with black color
            }
        }
    }
}




void ft_hook_one(mlx_key_data_t keydata, void *param) {
    t_objects *objects = (t_objects *)param;
    if (keydata.action == MLX_PRESS && keydata.key == MLX_KEY_ESCAPE)
        mlx_close_window(objects->mlx);
    if (keydata.action == MLX_PRESS && keydata.key == MLX_KEY_W && ft_check_wall(objects, -1, 0) == 0)
        upper_move(objects);
    if (keydata.action == MLX_PRESS && keydata.key == MLX_KEY_S && ft_check_wall(objects, +1, 0) == 0)
        down_move(objects);
    if (keydata.action == MLX_PRESS && keydata.key == MLX_KEY_A && ft_check_wall(objects, 0, -1) == 0)
        left_move(objects);
    if (keydata.action == MLX_PRESS && keydata.key == MLX_KEY_D && ft_check_wall(objects, 0, +1) == 0)
        right_move(objects);
}


void rotatePlayer(Player* player, double angle) {
    player->dirX = cos(angle) * player->dirX - sin(angle) * player->dirY;
    player->dirY = sin(angle) * player->dirX + cos(angle) * player->dirY;
}